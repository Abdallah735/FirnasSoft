

#########################################firist Version with arr[chan]###########################################################

package main

import (
	"database/sql"
	"fmt"
	"log"
	"math/rand"
	"time"

	_ "github.com/lib/pq"
)

const (
	host     = "localhost"
	port     = 5432
	user     = "postgres"
	password = "admin"
	dbname   = "db"
	//dbname = "postgres"
)

type Data struct {
	randomNumber int
	mod          int
}

func main() {
	// PostgreSQL connection string
	psqlInfo := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
		host, port, user, password, dbname)

	// Open the database connection
	db, err := sql.Open("postgres", psqlInfo)
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	// Verify the connection
	err = db.Ping()
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("Successfully connected to db!")

	//createTables(db)

	// Channel for data to be inserted
	var chans [5]chan Data //chans := make(chan Data,5)
	for i := range chans {
		chans[i] = make(chan Data)
	}

	// Start workers (goroutines) to handle data insertion
	for i := range chans {
		go worker(db, chans[i])
	}

	// Create a ticker that ticks every 5 seconds
	ticker := time.NewTicker(5 * time.Second)
	defer ticker.Stop()

	for {
		//select {
		//case
		<-ticker.C
		// Generate a random number and mod value
		randomNumber := rand.Intn(1000000)

		go func() {
			err = insertOnMainTable(db, randomNumber)
			if err != nil {
				log.Fatalf("Error inserting row into main_table: %v", err)
			}
			fmt.Println("Insertion done successfully on main_table")
		}()
		mod := randomNumber % 5
		// Send data to one channel
		chans[mod] <- Data{randomNumber, mod}

		//}
	}
}

// Worker function to handle data insertion based on mod value
func worker(db *sql.DB, dataChan chan Data) {
	for data := range dataChan {
		//data := <-dataChan
		err := insertOnTableMod(db, data.randomNumber, data.mod)
		if err != nil {
			log.Fatalf("Error inserting row into table_%d: %v", data.mod, err)
		}
		fmt.Printf("Insertion done successfully on table_%d\n", data.mod)
		//}
	}
}

func insertOnMainTable(db *sql.DB, r int) error {
	insertSQL := `INSERT INTO main_table (random_number,generation_time) VALUES ($1,$2);`
	_, err := db.Exec(insertSQL, r, time.Now())
	if err != nil {
		log.Fatalf("Error inserting row: %v", err)
	}
	return nil
}

func insertOnTableMod(db *sql.DB, r, mod int) error {
	insertSQL := fmt.Sprintf("INSERT INTO table_%d (random_number,reminder) VALUES ($1,$2);", mod)
	_, err := db.Exec(insertSQL, r, mod)
	if err != nil {
		log.Fatalf("Error inserting row: %v", err)
	}
	return nil
}

func createTables(db *sql.DB) {
	createTableSQL := `CREATE TABLE IF NOT EXISTS main_table (
		random_number int,
		generation_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
	);`
	_, err := db.Exec(createTableSQL)
	if err != nil {
		log.Fatalf("Error creating main_table: %v", err)
	} else {
		fmt.Println("Table 'main_table' created successfully!")
	}

	for i := 0; i < 5; i++ {
		createTableModSQL := fmt.Sprintf(`CREATE TABLE IF NOT EXISTS table_%d (
				random_number int,
				reminder int
			);`, i)
		_, err := db.Exec(createTableModSQL)
		if err != nil {
			log.Fatalf("Error creating table_%d: %v", i, err)
		} else {
			fmt.Printf("Table 'table_%d' created successfully!\n", i)
		}
	}
}

#########################################second version with ]###########################################################

package main

import (
	"database/sql"
	"fmt"
	"log"
	"math/rand"
	"time"

	_ "github.com/lib/pq"
)

const (
	host     = "localhost"
	port     = 5432
	user     = "postgres"
	password = "admin"
	dbname   = "db"
	//dbname = "postgres"
)

type Data struct {
	randomNumber int
	mod          int
}

func main() {
	// PostgreSQL connection string
	psqlInfo := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
		host, port, user, password, dbname)

	// Open the database connection
	db, err := sql.Open("postgres", psqlInfo)
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	// Verify the connection
	err = db.Ping()
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("Successfully connected to db!")

	//createTables(db)

	// Channel for data to be inserted
	chans := make(chan Data, 5)

	// Start workers (goroutines) to handle data insertion
	for i := 0; i < 5; i++ {
		go worker(db, chans)
	}

	// Create a ticker that ticks every 5 seconds
	ticker := time.NewTicker(5 * time.Second)
	defer ticker.Stop()

	for {
		<-ticker.C
		// Generate a random number and mod value
		randomNumber := rand.Intn(1000000)

		go func() {
			err = insertOnMainTable(db, randomNumber)
			if err != nil {
				log.Fatalf("Error inserting row into main_table: %v", err)
			}
			fmt.Println("Insertion done successfully on main_table")
		}()
		mod := randomNumber % 5
		// Send data to one channel
		chans <- Data{randomNumber, mod}

	}
}

// Worker function to handle data insertion based on mod value
func worker(db *sql.DB, dataChan chan Data) {
	for data := range dataChan {
		//data := <-dataChan
		err := insertOnTableMod(db, data.randomNumber, data.mod)
		if err != nil {
			log.Fatalf("Error inserting row into table_%d: %v", data.mod, err)
		}
		fmt.Printf("Insertion done successfully on table_%d\n", data.mod)
		//}
	}
}

func insertOnMainTable(db *sql.DB, r int) error {
	insertSQL := `INSERT INTO main_table (random_number,generation_time) VALUES ($1,$2);`
	_, err := db.Exec(insertSQL, r, time.Now())
	if err != nil {
		log.Fatalf("Error inserting row: %v", err)
	}
	return nil
}

func insertOnTableMod(db *sql.DB, r, mod int) error {
	insertSQL := fmt.Sprintf("INSERT INTO table_%d (random_number,reminder) VALUES ($1,$2);", mod)
	_, err := db.Exec(insertSQL, r, mod)
	if err != nil {
		log.Fatalf("Error inserting row: %v", err)
	}
	return nil
}

func createTables(db *sql.DB) {
	createTableSQL := `CREATE TABLE IF NOT EXISTS main_table (
		random_number int,
		generation_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
	);`
	_, err := db.Exec(createTableSQL)
	if err != nil {
		log.Fatalf("Error creating main_table: %v", err)
	} else {
		fmt.Println("Table 'main_table' created successfully!")
	}

	for i := 0; i < 5; i++ {
		createTableModSQL := fmt.Sprintf(`CREATE TABLE IF NOT EXISTS table_%d (
				random_number int,
				reminder int
			);`, i)
		_, err := db.Exec(createTableModSQL)
		if err != nil {
			log.Fatalf("Error creating table_%d: %v", i, err)
		} else {
			fmt.Printf("Table 'table_%d' created successfully!\n", i)
		}
	}
}
